using LabApi.Features.Console;
using LabApi.Loader.Features.Misc;
using LabApi.Loader.Features.Paths;
using LabApi.Loader.Features.Plugins;
using LabApi.Loader.Features.Configuration;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using LabApi.Features.Permissions;
using LabApi.Features.Permissions.Providers;
using LabApi.Features.Wrappers;
using LabApi.Loader.Features.Yaml;

namespace LabApi.Loader;

/// <summary>
/// LabAPIs plugin loader.
/// Responsible for loading all the different <see cref="Plugin"/>s.
/// </summary>
public static partial class PluginLoader
{
    private const string LoggerPrefix = "[LOADER]";
    private const string DllSearchPattern = "*.dll";
    private const string PdbFileExtension = ".pdb";
    private const string LabApiConfigName = "LabApi-{0}.yml";

    /// <summary>
    /// The current LabAPI configuration.
    /// </summary>
    public static LabApiConfig Config { get; private set; } = null!;

    /// <summary>
    /// Whether the <see cref="PluginLoader"/> has been initialized.
    /// </summary>
    public static bool Initialized { get; private set; }

    /// <summary>
    /// The loaded <see cref="Assembly"/> dependencies.
    /// </summary>
    public static HashSet<Assembly> Dependencies { get; } = [];

    /// <summary>
    /// The loaded <see cref="Plugin"/>s.
    /// </summary>
    public static Dictionary<Plugin, Assembly> Plugins { get; } = [];

    /// <summary>
    /// The enabled <see cref="Plugin"/>s.
    /// </summary>
    public static HashSet<Plugin> EnabledPlugins { get; } = [];

    /// <summary>
    /// Initializes the <see cref="PluginLoader"/> and loads all plugins.
    /// </summary>
    public static void Initialize()
    {
        // If the loader has already been initialized, we skip the initialization.
        if (Initialized)
            return;

        Initialized = true;

        // Load LabAPI configuration
        LoadLabApiConfig();

        // Initialize all wrappers
        InitializeWrappers();

        // We register all the commands in LabAPI to avoid plugin command conflicts.
        CommandLoader.RegisterCommands();

        // We first load all the dependencies and store them in the dependencies list
        LoadAllDependencies();

        // Then we load all the plugins and enable them
        LoadAllPlugins();

        // Resolve the server modded transparency flag
        ResolveTransparentlyModdedFlag();

        // We also register the default permissions provider
        PermissionsManager.RegisterProvider<DefaultPermissionsProvider>();
    }

    static partial void InitializeWrappers(); // The contents of this method will be generated by Source Generators

    /// <summary>
    /// Loads all dependencies from the configured dependency paths in <see cref="LabApiConfig.DependencyPaths"/>.
    /// Each path is relative to <see cref="PathManager.Dependencies"/> and supports port substitution.
    /// Creates the dependency directories if they don't exist.
    /// </summary>
    public static void LoadAllDependencies()
    {
        // We load all the dependencies from the configured dependency directories
        Logger.Info($"{LoggerPrefix} Loading all dependencies");

        foreach (string dependencyPath in Config.DependencyPaths)
        {
            string resolvedPath = ResolvePath(dependencyPath);
            string fullPath = Path.Combine(PathManager.Dependencies.FullName, resolvedPath);

            Directory.CreateDirectory(fullPath);

            LoadDependencies(new DirectoryInfo(fullPath).GetFiles(DllSearchPattern));
        }
    }

    /// <summary>
    /// Loads dependencies from a collection of files.
    /// </summary>
    /// <param name="files">The collection of assemblies to load.</param>
    public static void LoadDependencies(IEnumerable<FileInfo> files)
    {
        foreach (FileInfo file in files)
        {
            try
            {
                // We load the assembly from the specified file.
                Assembly assembly = Assembly.Load(File.ReadAllBytes(file.FullName));

                // And we add the assembly to the dependencies list.
                Dependencies.Add(assembly);

                // We finally log that the dependency has been loaded.
                Logger.Info($"{LoggerPrefix} Successfully loaded {assembly.FullName}");
            }
            catch (Exception e)
            {
                Logger.Error($"{LoggerPrefix} Couldn't load the dependency inside '{file.FullName}'");
                Logger.Error(e);
            }
        }
    }

    /// <summary>
    /// Loads all plugins from the configured plugin paths in <see cref="LabApiConfig.PluginPaths"/>.
    /// Each path is relative to <see cref="PathManager.Plugins"/> and supports port substitution.
    /// Creates the plugin directories if they don't exist.
    /// </summary>
    public static void LoadAllPlugins()
    {
        // We load all the plugins from the configured plugin directories
        Logger.Info($"{LoggerPrefix} Loading all plugins");

        foreach (string pluginPath in Config.PluginPaths)
        {
            string resolvedPath = ResolvePath(pluginPath);
            string fullPath = Path.Combine(PathManager.Plugins.FullName, resolvedPath);

            Directory.CreateDirectory(fullPath);

            if (Directory.Exists(fullPath))
                LoadPlugins(new DirectoryInfo(fullPath).GetFiles(DllSearchPattern));
        }

        // Then we finally enable all the plugins
        Logger.Info($"{LoggerPrefix} Enabling all plugins");
        EnablePlugins(Plugins.Keys.OrderBy(static plugin => plugin.Priority));
    }

    /// <summary>
    /// Loads plugins from a collection of files.
    /// </summary>
    /// <param name="files">The collection of assemblies to load.</param>
    public static void LoadPlugins(IEnumerable<FileInfo> files)
    {
        List<(FileInfo File, Assembly Assembly)> plugins = [];

        foreach (FileInfo file in files)
        {
            try
            {
                // We check if the file has a corresponding PDB file
                FileInfo pdb = new(Path.ChangeExtension(file.FullName, PdbFileExtension));

                // We load the assembly from the specified file.
                Assembly pluginAssembly = pdb.Exists
                    // In the case that the PDB file exists, we load the assembly with the PDB file.
                    ? Assembly.Load(File.ReadAllBytes(file.FullName), File.ReadAllBytes(pdb.FullName))
                    // Otherwise, we load the assembly without any debug information.
                    : Assembly.Load(File.ReadAllBytes(file.FullName));

                plugins.Add((file, pluginAssembly));
            }
            catch (Exception e)
            {
                Logger.Error($"{LoggerPrefix} Couldn't load the plugin inside '{file.FullName}'");
                Logger.Error(e);
            }
        }

        foreach ((FileInfo file, Assembly assembly) in plugins)
        {
            try
            {
                // If the assembly has missing dependencies, we skip it.
                if (AssemblyUtils.HasMissingDependencies(assembly, file.FullName, out Type[]? types))
                    continue;

                InstantiatePlugins(types, assembly, file.FullName);
            }
            catch (Exception e)
            {
                Logger.Error($"{LoggerPrefix} Couldn't load the plugin inside '{file.FullName}'");
                Logger.Error(e);
            }
        }
    }

    private static void InstantiatePlugins(Type[] types, Assembly assembly, string filePath)
    {
        foreach (Type type in types)
        {
            // We check if the type is derived from Plugin.
            if (!type.IsSubclassOf(typeof(Plugin)))
                continue;

            // We create an instance of the type and check if it was successfully created.
            if (Activator.CreateInstance(type) is not Plugin plugin)
                continue;

            // Set the file path
            plugin.FilePath = filePath;

            // In that case, we add the plugin to the plugins list and log that it has been loaded.
            Plugins.Add(plugin, assembly);
            Logger.Info($"{LoggerPrefix} Successfully loaded {plugin.Name}");
        }
    }

    /// <summary>
    /// Enables a collection of <see cref="Plugin"/>s.
    /// </summary>
    /// <param name="plugins">The sorted collection of <see cref="Plugin"/>s.</param>
    public static void EnablePlugins(IEnumerable<Plugin> plugins)
    {
        foreach (Plugin plugin in plugins)
        {
            // We try to load the configuration of the plugin
            if (!plugin.TryLoadProperties())
                continue;

            // We check if the plugin is enabled
            if (plugin.Properties?.IsEnabled == false)
                continue;

            // We finally enable the plugin
            EnablePlugin(plugin);
        }
    }

    /// <summary>
    /// Enables a <see cref="Plugin"/>.
    /// </summary>
    /// <param name="plugin">The <see cref="Plugin"/> to enable.</param>
    public static void EnablePlugin(Plugin plugin)
    {
        try
        {
            // We mark the server as modded.
            CustomNetworkManager.Modded = true;

            // We load the configurations of the plugin
            plugin.LoadConfigs();

            // We register all the plugin commands
            plugin.RegisterCommands();

            // We enable the plugin if it is not disabled
            plugin.Enable();

            // We add the plugin to the enabled plugins list
            EnabledPlugins.Add(plugin);

            // We finally log that the plugin has been enabled
            Logger.Info($"{LoggerPrefix} Successfully enabled {plugin}");
        }
        catch (Exception e)
        {
            Logger.Error($"{LoggerPrefix} Couldn't enable the plugin {plugin}");
            Logger.Error(e);
        }
    }

    /// <summary>
    /// Loads or creates the LabAPI configuration file.
    /// </summary>
    private static void LoadLabApiConfig()
    {
        string configPath = Path.Combine(PathManager.LabApi.FullName, string.Format(LabApiConfigName, Server.Port));
        Config = new LabApiConfig();

        try
        {
            if (File.Exists(configPath))
            {
                string content = File.ReadAllText(configPath);
                Config = YamlConfigParser.Deserializer.Deserialize<LabApiConfig>(content) ?? Config;
            }

            // Always save to update with any new properties
            string serialized = YamlConfigParser.Serializer.Serialize(Config);
            File.WriteAllText(configPath, serialized);
        }
        catch (Exception e)
        {
            Logger.Error($"{LoggerPrefix} Failed to load LabAPI configuration, using defaults");
            Logger.Error(e);
        }
    }

    /// <summary>
    /// Resolves whether the installed plugins are marked as transparent and sets the <see cref="Server.IsTransparentlyModded"/> flag based on the result.
    /// </summary>
    private static void ResolveTransparentlyModdedFlag()
    {
        if (Plugins.Count == 0)
            return;

        if (Server.IsTransparentlyModded)
            return;

        bool isTransparent = true;

        foreach (Plugin plugin in Plugins.Keys)
        {
            if (!plugin.IsTransparent)
            {
                isTransparent = false;
                break;
            }
        }

        Server.IsTransparentlyModded = isTransparent;

        if (isTransparent)
        {
            Logger.Raw($"{LoggerPrefix} This server has been flagged as transparently modded by one or more installed plugins. If you believe this is a mistake, please review your installed plugins and contact the plugin developers.", ConsoleColor.Red);
            ServerConsole.Update = true;
        }
    }

    private static string ResolvePath(string path)
    {
        return path.Replace("$port", Server.Port.ToString());
    }
}