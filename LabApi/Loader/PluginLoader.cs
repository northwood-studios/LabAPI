using LabApi.Features.Console;
using LabApi.Loader.Features.Misc;
using LabApi.Loader.Features.Paths;
using LabApi.Loader.Features.Plugins;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using LabApi.Features.Permissions;
using LabApi.Features.Permissions.Providers;

namespace LabApi.Loader;

/// <summary>
/// LabAPIs plugin loader.
/// Responsible for loading all the different <see cref="Plugin"/>s.
/// </summary>
public static partial class PluginLoader
{
    private const string LoggerPrefix = "[LOADER]";
    private const string DllSearchPattern = "*.dll";
    private const string PdbFileExtension = ".pdb";

    /// <summary>
    /// Whether the <see cref="PluginLoader"/> has been initialized.
    /// </summary>
    public static bool Initialized { get; private set; }

    /// <summary>
    /// The loaded <see cref="Assembly"/> dependencies.
    /// </summary>
    public static HashSet<Assembly> Dependencies { get; } = [];

    /// <summary>
    /// The loaded <see cref="Plugin"/>s.
    /// </summary>
    public static Dictionary<Plugin, Assembly> Plugins { get; } = [];

    /// <summary>
    /// The enabled <see cref="Plugin"/>s.
    /// </summary>
    public static HashSet<Plugin> EnabledPlugins { get; } = [];

    /// <summary>
    /// Initializes the <see cref="PluginLoader"/> and loads all plugins.
    /// </summary>
    public static void Initialize()
    {
        // If the loader has already been initialized, we skip the initialization.
        if (Initialized)
            return;

        Initialized = true;

        // Initialize all wrappers
        InitializeWrappers();

        // We register all the commands in LabAPI to avoid plugin command conflicts.
        CommandLoader.RegisterCommands();

        // We first load all the dependencies and store them in the dependencies list
        LoadAllDependencies();
        // Then we load all the plugins and enable them
        LoadAllPlugins();

        // We also register the default permissions provider
        PermissionsManager.RegisterProvider<DefaultPermissionsProvider>();
    }

    static partial void InitializeWrappers(); // This will be generated by InitializeWrappers.tt

    /// <summary>
    /// Loads all dependencies found inside the <see cref="PathManager.Dependencies"/> directory.
    /// </summary>
    public static void LoadAllDependencies()
    {
        // We load all the dependencies from the dependencies directory
        Logger.Info($"{LoggerPrefix} Loading all dependencies");
        LoadDependencies(PathManager.Dependencies.GetFiles(DllSearchPattern));
    }

    /// <summary>
    /// Loads dependencies from a collection of files.
    /// </summary>
    /// <param name="files">The collection of assemblies to load.</param>
    public static void LoadDependencies(IEnumerable<FileInfo> files)
    {
        foreach (FileInfo file in files)
        {
            try
            {
                // We load the assembly from the specified file.
                Assembly assembly = Assembly.Load(File.ReadAllBytes(file.FullName));

                // And we add the assembly to the dependencies list.
                Dependencies.Add(assembly);

                // We finally log that the dependency has been loaded.
                Logger.Info($"{LoggerPrefix} Successfully loaded {assembly.FullName}");
            }
            catch (Exception e)
            {
                Logger.Error($"{LoggerPrefix} Couldn't load the dependency inside '{file.FullName}'");
                Logger.Error(e);
            }
        }
    }

    /// <summary>
    /// Loads all plugins found inside the <see cref="PathManager.Plugins"/> directory.
    /// </summary>
    public static void LoadAllPlugins()
    {
        // First we load all the plugins from the plugins directory
        Logger.Info($"{LoggerPrefix} Loading all plugins");
        LoadPlugins(PathManager.Plugins.GetFiles(DllSearchPattern));

        // Then we finally enable all the plugins
        Logger.Info($"{LoggerPrefix} Enabling all plugins");
        EnablePlugins(Plugins.Keys.OrderBy(plugin => plugin.Priority));
    }

    /// <summary>
    /// Loads plugins from a collection of files.
    /// </summary>
    /// <param name="files">The collection of assemblies to load.</param>
    public static void LoadPlugins(IEnumerable<FileInfo> files)
    {
        List<(FileInfo File, Assembly Assembly)> plugins = [];

        foreach (FileInfo file in files)
        {
            try
            {
                // We check if the file has a corresponding PDB file
                FileInfo pdb = new(Path.ChangeExtension(file.FullName, PdbFileExtension));

                // We load the assembly from the specified file.
                Assembly pluginAssembly = pdb.Exists
                    // In the case that the PDB file exists, we load the assembly with the PDB file.
                    ? Assembly.Load(File.ReadAllBytes(file.FullName), File.ReadAllBytes(pdb.FullName))
                    // Otherwise, we load the assembly without any debug information.
                    : Assembly.Load(File.ReadAllBytes(file.FullName));

                plugins.Add((file, pluginAssembly));
            }
            catch (Exception e)
            {
                Logger.Error($"{LoggerPrefix} Couldn't load the plugin inside '{file.FullName}'");
                Logger.Error(e);
            }
        }

        foreach ((FileInfo file, Assembly assembly) in plugins)
        {
            try
            {
                // If the assembly has missing dependencies, we skip it.
                if (AssemblyUtils.HasMissingDependencies(assembly, file.FullName, out Type[]? types))
                    continue;

                InstantiatePlugins(types, assembly);
            }
            catch (Exception e)
            {
                Logger.Error($"{LoggerPrefix} Couldn't load the plugin inside '{file.FullName}'");
                Logger.Error(e);
            }
        }
    }

    private static void InstantiatePlugins(Type[] types, Assembly assembly)
    {
        foreach (Type type in types)
        {
            // We check if the type is derived from Plugin.
            if (!type.IsSubclassOf(typeof(Plugin)))
                continue;

            // We create an instance of the type and check if it was successfully created.
            if (Activator.CreateInstance(type) is not Plugin plugin)
                continue;

            // In that case, we add the plugin to the plugins list and log that it has been loaded.
            Plugins.Add(plugin, assembly);
            Logger.Info($"{LoggerPrefix} Successfully loaded {plugin.Name}");
        }
    }

    /// <summary>
    /// Enables a collection of <see cref="Plugin"/>s.
    /// </summary>
    /// <param name="plugins">The sorted collection of <see cref="Plugin"/>s.</param>
    public static void EnablePlugins(IEnumerable<Plugin> plugins)
    {
        foreach (Plugin plugin in plugins)
        {
            // We try to load the configuration of the plugin
            if (!plugin.TryLoadProperties())
                continue;

            // We check if the plugin is enabled
            if (plugin.Properties?.IsEnabled == false)
                continue;

            // We finally enable the plugin
            EnablePlugin(plugin);
        }
    }

    /// <summary>
    /// Enables a <see cref="Plugin"/>.
    /// </summary>
    /// <param name="plugin">The <see cref="Plugin"/> to enable.</param>
    public static void EnablePlugin(Plugin plugin)
    {
        try
        {
            // We register all the plugin commands
            plugin.RegisterCommands();

            // We load the configurations of the plugin
            plugin.LoadConfigs();

            // We enable the plugin if it is not disabled
            plugin.Enable();

            // We add the plugin to the enabled plugins list
            EnabledPlugins.Add(plugin);

            // We finally log that the plugin has been enabled
            Logger.Info($"{LoggerPrefix} Successfully enabled {plugin}");
        }
        catch (Exception e)
        {
            Logger.Error($"{LoggerPrefix} Couldn't enable the plugin {plugin}");
            Logger.Error(e);
        }
    }
}